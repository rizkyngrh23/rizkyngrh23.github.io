<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Understanding Asynchronous JavaScript - Rizky Portfolio Website</title>
    <link rel="stylesheet" href="../styles.css">
    <style>
        .code-box {
            background-color: #f4f4f4;
            border-left: 4px solid #88aaee;
            padding: 10px;
            margin: 20px 0;
            overflow-x: auto;
        }
        .code-box code {
            display: block;
            white-space: pre-wrap;
        }
    </style>
</head>
<body>
    <header>
        <h1>Understanding Asynchronous JavaScript</h1>
    </header>
    <nav>
        <a href="../index.html">Home</a>
        <a href="../projects.html">Projects</a>
        <a href="../profile.html">Profile</a>
        <a href="../blog.html">Blog</a>
        <a href="../contact.html">Contact Me</a>
    </nav>
    <button class="dark-mode-toggle">Toggle Dark Mode</button>
    <div class="container" id="blog-post" style="text-align: justify;">
        <h1>Understanding Asynchronous JavaScript</h1>
        <p>Asynchronous programming is a key feature of JavaScript that allows you to perform long-running tasks without blocking the main thread. This is essential for creating responsive web applications. In this article, we'll explore the basics of asynchronous JavaScript, including callbacks, promises, and async/await.</p>
        
        <h2>Callbacks</h2>
        <p>A callback is a function that is passed as an argument to another function and is executed after some operation has been completed. Here's an example of using a callback in JavaScript:</p>
        <div class="code-box">
            <code class="language-javascript">function fetchData(callback) {
    setTimeout(() => {
        const data = 'Hello, World!';
        callback(data);
    }, 1000);
}

function displayData(data) {
    console.log(data);
}

fetchData(displayData);</code>
        </div>
        <p>In this example, the <code>fetchData</code> function simulates an asynchronous operation using <code>setTimeout</code>. Once the operation is complete, it calls the <code>displayData</code> function with the fetched data.</p>
        
        <h2>Promises</h2>
        <p>Promises provide a more powerful and flexible way to handle asynchronous operations. A promise represents a value that may be available now, or in the future, or never. Here's an example of using promises in JavaScript:</p>
        <div class="code-box">
            <code class="language-javascript">function fetchData() {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            const data = 'Hello, World!';
            resolve(data);
        }, 1000);
    });
}

fetchData()
    .then(data => {
        console.log(data);
    })
    .catch(error => {
        console.error(error);
    });</code>
        </div>
        <p>In this example, the <code>fetchData</code> function returns a promise that resolves with the fetched data after a delay. The <code>then</code> method is used to handle the resolved value, and the <code>catch</code> method is used to handle any errors.</p>
        
        <h2>Async/Await</h2>
        <p>Async/await is a syntactic sugar built on top of promises that allows you to write asynchronous code in a more synchronous manner. Here's an example of using async/await in JavaScript:</p>
        <div class="code-box">
            <code class="language-javascript">async function fetchData() {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            const data = 'Hello, World!';
            resolve(data);
        }, 1000);
    });
}

async function displayData() {
    try {
        const data = await fetchData();
        console.log(data);
    } catch (error) {
        console.error(error);
    }
}

displayData();</code>
        </div>
        <p>In this example, the <code>fetchData</code> function returns a promise, and the <code>displayData</code> function uses the <code>await</code> keyword to wait for the promise to resolve. The <code>try</code>/<code>catch</code> block is used to handle any errors.</p>
        
        <h2>Conclusion</h2>
        <p>In this article, we've covered the basics of asynchronous JavaScript, including callbacks, promises, and async/await. Understanding these concepts is essential for building responsive and efficient web applications. From here, you can explore more advanced topics like error handling, parallel execution, and async iterators.</p>
        <p>Happy coding!</p>
    </div>
    <footer>
        <p>&copy; 2024 Rizky Portfolio Website</p>
    </footer>
    <script src="../scripts.js"></script>
</body>
</html>